<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æ²‰æµ¸å¼å¡”ç½—å åœ - å‘½è¿ç»‡æœº Master</title>
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥ MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <!-- å¼•å…¥ Tween.js ç”¨äºåŠ¨ç”» -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+SC:wght@300;400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            /* ä¼˜åŒ–èƒŒæ™¯ï¼šä¸­å¿ƒæäº®ä¸ºæ·±é›è“ï¼Œå¢åŠ å¯¹æ¯”åº¦ï¼Œä¸å†æ˜¯æ­»é»‘ */
            background: radial-gradient(circle at center, #231a33 0%, #130f1f 40%, #050505 100%);
            font-family: 'Noto Serif SC', serif;
            color: #e0d0b0;
            user-select: none;
        }

        #input_video {
            position: absolute;
            top: 0; left: 0; opacity: 0; pointer-events: none;
            width: 1px; height: 1px;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        .top-bar {
            padding: 20px;
            text-align: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent); /* ç¨å¾®è°ƒæ·¡ */
            pointer-events: auto;
        }

        h1 {
            margin: 0;
            font-family: 'Cinzel', serif;
            font-size: 26px;
            letter-spacing: 4px;
            color: #ffd700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.6); /* å¢å¼ºæ ‡é¢˜å‘å…‰ */
        }

        /* é€šç”¨æ¨¡æ€æ¡† */
        .modal-screen {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 15, 30, 0.85); /* å¢åŠ é€æ˜åº¦ */
            border: 1px solid rgba(212, 175, 55, 0.4);
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.8), inset 0 0 20px rgba(212, 175, 55, 0.05);
            pointer-events: auto;
            width: 90%; max-width: 420px;
            transition: opacity 0.4s, transform 0.4s;
            backdrop-filter: blur(12px); /* ç£¨ç ‚æ„Ÿå¢å¼º */
        }

        .hidden { opacity: 0; pointer-events: none; transform: translate(-50%, -60%); display: none; }

        input[type="text"] {
            width: 90%;
            padding: 12px;
            margin: 20px 0;
            background: rgba(255,255,255,0.08);
            border: 1px solid #666;
            color: #ffd700;
            font-family: 'Noto Serif SC', serif;
            font-size: 16px;
            text-align: center;
            border-radius: 4px;
        }
        input[type="text"]:focus { border-color: #ffd700; outline: none; background: rgba(255,255,255,0.15); }

        button {
            background: linear-gradient(45deg, #443355, #111);
            border: 1px solid #ffd700;
            color: #ffd700;
            padding: 10px 30px;
            font-size: 15px;
            letter-spacing: 1px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            transition: all 0.3s;
            margin-top: 10px;
        }
        button:hover { background: #ffd700; color: #000; box-shadow: 0 0 20px #ffd700; }
        button:disabled { border-color: #555; color: #777; background: #111; cursor: not-allowed; box-shadow: none; }

        /* å¡æ§½ - åˆå§‹éšè— */
        #card-slots {
            position: absolute;
            bottom: 0; width: 100%;
            display: none; /* åˆå§‹ä¸å±•ç¤º */
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 30px;
            gap: 20px;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            height: 220px;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 1s;
        }

        .slot {
            width: 80px; height: 130px;
            border: 1px dashed rgba(255, 215, 0, 0.3);
            border-radius: 6px;
            display: flex; justify-content: center; align-items: center;
            position: relative;
            background: rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .slot img {
            width: 100%; height: 100%;
            object-fit: cover;
            opacity: 0; transition: opacity 0.5s;
        }

        .slot.filled { border-style: solid; border-color: #ffd700; box-shadow: 0 0 15px rgba(255, 215, 0, 0.3); }
        .slot.filled img { opacity: 1; }

        .card-name-tag {
            position: absolute; bottom: 0; width: 100%;
            background: rgba(0,0,0,0.8); color: #ffd700;
            font-size: 10px; text-align: center; padding: 2px 0;
            display: none;
        }
        .slot.filled .card-name-tag { display: block; }

        /* è§£è¯»é¢æ¿ */
        #reading-panel {
            position: absolute;
            top: 55%; left: 50%;
            transform: translate(-50%, -50%);
            width: 85%; height: 80%;
            max-width: 600px;
            background: rgba(20, 18, 35, 0.95);
            border: 1px solid #ffd700;
            border-radius: 12px;
            display: none;
            flex-direction: column;
            pointer-events: auto;
            box-shadow: 0 0 60px rgba(0,0,0,0.8);
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        #reading-header {
            padding: 20px; border-bottom: 1px solid #333;
            display: flex; justify-content: center; gap: 20px;
            background: rgba(0,0,0,0.2);
        }
        
        .header-card {
            width: 60px; text-align: center;
        }
        .header-card img {
            width: 60px; height: 96px; border-radius: 4px;
            border: 1px solid #666; box-shadow: 0 0 10px rgba(0,0,0,0.5);
            margin-bottom: 5px;
        }
        .header-card span { font-size: 10px; color: #aaa; display: block; line-height: 1.2;}
        .header-card strong { color: #ffd700; font-weight: normal;}

        #reading-scroll-area {
            flex: 1; overflow-y: auto; padding: 20px;
            font-size: 15px; line-height: 1.6; color: #ddd;
        }
        #reading-scroll-area::-webkit-scrollbar { width: 5px; }
        #reading-scroll-area::-webkit-scrollbar-thumb { background: #444; border-radius: 2px; }

        .msg-box { margin-bottom: 20px; animation: fadeIn 0.5s; }
        .msg-sys { color: #e0d0b0; }
        .msg-user { color: #aaa; text-align: right; font-style: italic; border-right: 2px solid #555; padding-right: 10px;}
        .highlight { color: #ffd700; font-weight: bold; }
        
        /* é—ªçƒçš„åŠ è½½ç‚¹ */
        .loading-dots::after {
            content: ' .';
            animation: dots 1.5s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { color: rgba(0,0,0,0); text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0);}
            40% { color: white; text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0);}
            60% { text-shadow: .25em 0 0 white, .5em 0 0 rgba(0,0,0,0);}
            80%, 100% { text-shadow: .25em 0 0 white, .5em 0 0 white;}
        }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        #reading-footer {
            padding: 15px; border-top: 1px solid #333;
            background: rgba(0,0,0,0.3);
        }

        #follow-up-container { display: flex; gap: 10px; margin-bottom: 10px; }
        #follow-up-input { flex: 1; margin: 0; text-align: left; padding-left: 10px;}
        #btn-follow-up { margin: 0; padding: 10px 15px; width: auto;}

        /* æ‰‹åŠ¿å…‰æ ‡ */
        #gesture-cursor {
            position: absolute; width: 20px; height: 20px;
            border: 2px solid #fff; border-radius: 50%;
            pointer-events: none; transform: translate(-50%, -50%);
            z-index: 50; display: none;
            transition: border-color 0.2s, transform 0.1s;
        }
        #gesture-cursor.pinching { border-color: #ffd700; background: rgba(255, 215, 0, 0.3); transform: translate(-50%, -50%) scale(0.8); }

        .helper-text {
            position: absolute; bottom: 220px; width: 100%;
            text-align: center; color: rgba(255,255,255,0.5); font-size: 13px;
            pointer-events: none; text-shadow: 0 0 5px #000;
        }

        /* çŠ¶æ€æç¤º */
        #toast {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(200, 50, 50, 0.9); color: white; padding: 10px 20px;
            border-radius: 5px; opacity: 0; transition: opacity 0.5s; pointer-events: none;
        }

        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
        .cursor-pointer { cursor: pointer; }
    </style>
</head>
<body>

    <video id="input_video"></video>
    <div id="canvas-container"></div>
    <div id="gesture-cursor"></div>
    <div id="toast">æç¤ºä¿¡æ¯</div>

    <div id="ui-layer">
        <div class="top-bar">
            <h1>Laura å¡”ç½—</h1>
            <div style="font-size: 12px; color: #888;">æ²‰æµ¸å¼çµè§†å åœ</div>
        </div>

        <div class="helper-text" id="status-text">åˆå§‹åŒ–ç³»ç»Ÿ...</div>

        <!-- 1. æé—®ä¸æƒé™ -->
        <div id="input-screen" class="modal-screen">
            <h2 style="color:#ffd700">å¼€å¯çµè§†</h2>
            <p style="color:#ccc; font-size:13px; margin: 20px 0; line-height: 1.6;">
                èšç„¦ä½ çš„æ„å¿µï¼Œé—®é¢˜è¶Šå…·ä½“ï¼ŒæŒ‡å¼•è¶Šæ¸…æ™°
            </p>
            <input type="text" id="initial-question" placeholder="ä¾‹å¦‚: æˆ‘ä»Šå¹´çš„å·¥ä½œè¿åŠ¿å¦‚ä½•?" maxlength="50">
            <button id="btn-submit-q">å¼€å¯å‘½è¿ä¹‹é—¨</button>
        </div>

        <!-- 3. æŠ½ç‰Œ (Canvasäº¤äº’) -->
        <div id="card-slots">
            <div class="slot" id="slot-0">
                <img id="img-0" src="" alt="">
                <div class="card-name-tag" id="tag-0"></div>
            </div>
            <div class="slot" id="slot-1">
                <img id="img-1" src="" alt="">
                <div class="card-name-tag" id="tag-1"></div>
            </div>
            <div class="slot" id="slot-2">
                <img id="img-2" src="" alt="">
                <div class="card-name-tag" id="tag-2"></div>
            </div>
        </div>

        <!-- 4. è§£è¯» -->
        <div id="reading-panel">
            <div id="reading-header">
                <!-- åŠ¨æ€å¡«å……å›¾ç‰‡ -->
            </div>
            <div id="reading-scroll-area">
                <!-- èŠå¤©æµ -->
            </div>
            <div id="reading-footer">
                <div id="follow-up-container">
                    <input type="text" id="follow-up-input" placeholder="è¾“å…¥è¿½é—® (æœ€å¤š3æ¬¡)...">
                    <button id="btn-follow-up">è¿½é—®</button>
                </div>
                <button id="btn-end-reading" style="width:100%; background: #222; border-color: #444;">ç»“æŸæœ¬æ¬¡å åœ</button>
            </div>
        </div>
    </div>

<script>
/**
 * å¡”ç½—æ•°æ® (ç»å…¸éŸ¦ç‰¹) & å›¾ç‰‡æ˜ å°„é€»è¾‘
 */
const MAJORS = [
    "æ„šè€…", "é­”æœ¯å¸ˆ", "å¥³ç¥­å¸", "çš‡å", "çš‡å¸", "æ•™çš‡", "æ‹äºº", "æˆ˜è½¦",
    "åŠ›é‡", "éšå£«", "å‘½è¿ä¹‹è½®", "æ­£ä¹‰", "å€’åŠäºº", "æ­»ç¥", "èŠ‚åˆ¶", "æ¶é­”",
    "é«˜å¡”", "æ˜Ÿæ˜Ÿ", "æœˆäº®", "å¤ªé˜³", "å®¡åˆ¤", "ä¸–ç•Œ"
];
// Sacred Texts æ–‡ä»¶åæ˜ å°„
// Major: ar00.jpg - ar21.jpg
const SUITS = [
    { name: "æƒæ–", id: "Wands", fileCode: "wa" }, 
    { name: "åœ£æ¯", id: "Cups", fileCode: "cu" }, 
    { name: "å®å‰‘", id: "Swords", fileCode: "sw" }, 
    { name: "æ˜Ÿå¸", id: "Pentacles", fileCode: "pe" }
];
const RANKS = ["Ace", "2", "3", "4", "5", "6", "7", "8", "9", "10", "ä¾ä»", "éª‘å£«", "ç‹å", "å›½ç‹"];
const RANK_CODES = ["ac", "02", "03", "04", "05", "06", "07", "08", "09", "10", "pa", "kn", "qu", "ki"];

let TAROT_DECK = [];

// ç”Ÿæˆå¤§é˜¿å¡çº³
MAJORS.forEach((name, i) => {
    const num = i < 10 ? '0' + i : i;
    TAROT_DECK.push({ 
        id: i, 
        name, 
        type: 'Major', 
        imgUrl: `https://www.sacred-texts.com/tarot/pkt/img/ar${num}.jpg`
    });
});

// ç”Ÿæˆå°é˜¿å¡çº³
let idCounter = 22;
SUITS.forEach(suit => {
    RANKS.forEach((rank, rIndex) => {
        TAROT_DECK.push({ 
            id: idCounter++, 
            name: `${suit.name}${rank}`, 
            type: 'Minor', 
            suit: suit, 
            rankName: rank, 
            imgUrl: `https://www.sacred-texts.com/tarot/pkt/img/${suit.fileCode}${RANK_CODES[rIndex]}.jpg`
        });
    });
});

/**
 * æ ¸å¿ƒ App é€»è¾‘
 */
const App = {
    scene: null, camera: null, renderer: null,
    sphereGroup: null, 
    cloudGroup: null, // çƒŸé›¾ç²’å­ç»„
    cards: [], raycaster: new THREE.Raycaster(),
    
    state: 'INIT',
    userQuestion: '',
    drawnCards: [],
    maxCards: 3,
    followUpCount: 0,
    apiKey: "", // API Key provided by environment
    
    // äº¤äº’ç‰©ç†é‡
    targetRotX: 0, targetRotY: 0,
    currentRotX: 0, currentRotY: 0,
    hoveredCard: null,
    mouseDownTime: 0,
    isRotating: false, 

    // æ‰‹åŠ¿å˜é‡
    handMode: 'NONE', 
    lastHandPos: { x: 0.5, y: 0.5 },

    init: function() {
        this.initThree();
        this.initUI();
        this.startMediaPipe(); 
        this.animate();
        this.updateStatus('è¯·å…è®¸æ‘„åƒå¤´æƒé™ä»¥å¼€å¯æ‰‹åŠ¿é­”æ³• <br><span style="font-size:12px; opacity:0.8; letter-spacing:1px;">ğŸ‘‹ å¼ æ‰‹æ—‹è½¬ | ğŸ‘† é£ŸæŒ‡ç„å‡† | ğŸ‘Œ æåˆæŠ½å–</span>');
    },

    initThree: function() {
        const container = document.getElementById('canvas-container');
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.FogExp2(0x130f1f, 0.02);

        // è°ƒæ•´æ‘„åƒæœºè·ç¦»
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.z = 28;

        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(this.renderer.domElement);

        // --- ç¯å…‰å‡çº§ ---
        // ç¯å¢ƒå…‰
        const amb = new THREE.AmbientLight(0x404040, 2.0);
        this.scene.add(amb);
        
        // ä¸»å…‰æº (æš–è‰²ï¼Œå·¦å‰)
        const p1 = new THREE.PointLight(0xffddaa, 1.5, 60);
        p1.position.set(10, 10, 15);
        this.scene.add(p1);
        
        // è¡¥å…‰ (å†·è‰²ï¼Œå†…éƒ¨)
        const p2 = new THREE.PointLight(0x8a2be2, 2.0, 40); 
        p2.position.set(0, 0, 0); 
        this.scene.add(p2);

        // è¾¹ç¼˜å…‰ (Rim Light) - å…³é”®ï¼šä»èƒŒé¢å‹¾å‹’æ°´æ™¶çƒè½®å»“
        const rimLight = new THREE.SpotLight(0xaaddff, 3.0, 50, Math.PI/3, 0.5, 1);
        rimLight.position.set(0, 10, -20);
        rimLight.lookAt(0, 0, 0);
        this.scene.add(rimLight);

        this.sphereGroup = new THREE.Group();
        this.scene.add(this.sphereGroup);

        this.initCrystalBall();

        // å¤–éƒ¨ç¯å¢ƒç²’å­ (èƒŒæ™¯æ˜Ÿå°˜)
        const pGeo = new THREE.BufferGeometry();
        const pPos = [];
        for(let i=0; i<800; i++) {
            // æ‰©æ•£åˆ°è¿œå¤„
            const r = 20 + Math.random() * 60;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            pPos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
        }
        pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
        this.scene.add(new THREE.Points(pGeo, new THREE.PointsMaterial({color:0x88aaff, size:0.1, transparent:true, opacity: 0.5})));

        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth/window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });

        this.initMouseEvents();
    },

    // è¾…åŠ©ï¼šç”Ÿæˆç¨‹åºåŒ–çƒŸé›¾çº¹ç† (å¾„å‘æ¸å˜)
    createSmokeTexture: function() {
        const size = 128;
        const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        const grad = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
        // æŸ”å’Œçš„äº‘é›¾ï¼šä¸­å¿ƒæ·¡ç™½ï¼Œè¾¹ç¼˜é€æ˜
        grad.addColorStop(0, 'rgba(220, 220, 255, 0.6)'); 
        grad.addColorStop(0.4, 'rgba(150, 100, 200, 0.2)');
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, size, size);
        
        return new THREE.CanvasTexture(canvas);
    },

    initCrystalBall: function() {
        // 1. èƒ½é‡æ ¸å¿ƒ (å…‰æ™•)
        const coreTexture = this.createSmokeTexture();
        const coreMat = new THREE.SpriteMaterial({ 
            map: coreTexture, 
            color: 0xffd700, 
            blending: THREE.AdditiveBlending,
            opacity: 0.8
        });
        const coreSprite = new THREE.Sprite(coreMat);
        coreSprite.scale.set(7, 7, 7);
        this.sphereGroup.add(coreSprite);

        // 2. çœŸå®äº‘é›¾ç³»ç»Ÿ (Volumetric Mist Particles)
        const cloudCount = 250;
        const cloudGeo = new THREE.BufferGeometry();
        const cloudPos = [];
        
        for(let i=0; i<cloudCount; i++) {
            // åœ¨çƒä½“å†…éƒ¨éšæœºåˆ†å¸ƒ (åŠå¾„ 0 ~ 9)
            const r = Math.pow(Math.random(), 0.5) * 9; 
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            cloudPos.push(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
        }
        cloudGeo.setAttribute('position', new THREE.Float32BufferAttribute(cloudPos, 3));

        const cloudMat = new THREE.PointsMaterial({
            map: coreTexture, // å¤ç”¨çƒŸé›¾çº¹ç†
            size: 5, 
            color: 0x9370db, // æµ…ç´«è‰²
            transparent: true,
            opacity: 0.12, // éå¸¸æ·¡ï¼Œå åŠ å‡ºä½“ç§¯æ„Ÿ
            depthWrite: false, // å…³é”®ï¼šäº‘é›¾ä¹‹é—´ä¸é®æŒ¡
            blending: THREE.AdditiveBlending
        });
        this.cloudGroup = new THREE.Points(cloudGeo, cloudMat);
        this.sphereGroup.add(this.cloudGroup);

        // 3. æ°´æ™¶çƒå¤–å£³ (ç‰©ç†æè´¨ - æè‡´é€šé€)
        // æé«˜åˆ†æ®µæ•°è‡³ 128 ä»¥æ¶ˆé™¤è¾¹ç¼˜æ£±è§’
        const glassGeo = new THREE.SphereGeometry(11, 128, 128); 
        const glassMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, // çº¯å‡€åŸºè‰²ï¼Œä¸è¦å¸¦è‰²å
            transmission: 0.99, // æ¥è¿‘å®Œç¾é€å…‰
            opacity: 1.0,
            metalness: 0.0, 
            roughness: 0.0, // å®Œç¾æŠ›å…‰
            ior: 1.6, // æ°´æ™¶æŠ˜å°„ç‡
            thickness: 1.0, // è¾ƒè–„çš„åšåº¦ï¼Œå‡å°‘å†…éƒ¨æ‰­æ›²
            clearcoat: 1.0, // å¼ºé«˜å…‰
            clearcoatRoughness: 0.0,
            // å…³é”®ä¿®æ”¹ï¼šç§»é™¤ attenuationColor æˆ–è®¾ä¸ºææ·¡ï¼Œé˜²æ­¢å˜é»‘
            attenuationColor: new THREE.Color(0xffffff), 
            attenuationDistance: Infinity, 
            side: THREE.FrontSide, 
            transparent: true,
            depthWrite: false 
        });
        const glassSphere = new THREE.Mesh(glassGeo, glassMat);
        this.sphereGroup.add(glassSphere);
        
        // 4. è¡¨é¢é­”æ³•å¾®ç²’
        const magicGeo = new THREE.BufferGeometry();
        const magicPos = [];
        for(let i=0; i<150; i++) {
            const r = 11.2; 
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            magicPos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
        }
        magicGeo.setAttribute('position', new THREE.Float32BufferAttribute(magicPos, 3));
        const magicMat = new THREE.PointsMaterial({
            color: 0xaaddff, size: 0.2, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
        });
        this.magicParticles = new THREE.Points(magicGeo, magicMat);
        this.sphereGroup.add(this.magicParticles);
    },

    createCardBackTexture: function() {
        const cvs = document.createElement('canvas');
        cvs.width = 256; cvs.height = 400;
        const ctx = cvs.getContext('2d');
        const grd = ctx.createRadialGradient(128, 200, 20, 128, 200, 200);
        grd.addColorStop(0, '#3a1c52'); grd.addColorStop(1, '#0f0518');
        ctx.fillStyle = grd; ctx.fillRect(0,0,256,400);
        ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 4; ctx.strokeRect(10,10,236,380);
        ctx.translate(128, 200);
        ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(0,0,80,0,Math.PI*2); ctx.stroke();
        for(let i=0; i<6; i++) {
            ctx.rotate(Math.PI/3); ctx.beginPath(); ctx.arc(0, 80, 40, 0, Math.PI*2); ctx.stroke();
        }
        return new THREE.CanvasTexture(cvs);
    },

    // 3D åœºæ™¯ä¸­çš„å¡ç‰Œè´´å›¾ (åŠ è½½å¤–éƒ¨å›¾ç‰‡)
    loadCardTexture: function(imgUrl, isReversed) {
        const loader = new THREE.TextureLoader();
        // è®¾ç½®è·¨åŸŸï¼Œè™½sacred-textsä¸ä¸€å®šæ”¯æŒCORSï¼Œä½†ä½œä¸ºçº¹ç†åœ¨canvasé‡Œå¦‚æœä¸éœ€è¦toDataURLæ˜¯okçš„
        // ä¸ºä¿é™©èµ·è§ï¼Œå¦‚æœCORSå¤±è´¥ï¼ŒThreeJSä¼šæ˜¾ç¤ºé»‘è‰²ã€‚
        // è¿™é‡Œå°è¯•ä½¿ç”¨ã€‚
        const tex = loader.load(imgUrl);
        // å¦‚æœæ˜¯é€†ä½ï¼Œè°ƒæ•´çº¹ç†æ—‹è½¬
        if (isReversed) {
            tex.center.set(0.5, 0.5);
            tex.rotation = Math.PI;
        }
        return tex;
    },

    initUI: function() {
        const btnSubmit = document.getElementById('btn-submit-q');
        const inputQ = document.getElementById('initial-question');

        btnSubmit.addEventListener('click', () => {
            const val = inputQ.value.trim();
            const isQuestion = /[?ï¼Ÿå—å‘¢å’‹å¦‚ä½•å“ªä»€ä¹ˆæ€ä¹ˆæ€ä¹ˆæ ·å’‹æ ·]/.test(val) && val.length > 2;
            
            if (!isQuestion) {
                this.showToast("è¯·å‘æ°´æ™¶çƒæå‡ºä¸€ä¸ªå…·ä½“çš„é—®é¢˜ã€‚");
                return;
            }
            
            this.userQuestion = val;
            this.startShuffling();
        });

        document.getElementById('btn-follow-up').addEventListener('click', () => this.handleFollowUp());
        document.getElementById('btn-end-reading').addEventListener('click', () => location.reload());
    },

    showToast: function(msg) {
        const t = document.getElementById('toast');
        t.innerText = msg; t.style.opacity = 1;
        setTimeout(() => t.style.opacity = 0, 3000);
    },

    startShuffling: function() {
        this.state = 'SHUFFLING';
        document.getElementById('input-screen').classList.add('hidden');
        this.updateStatus('å‘½è¿æ´—ç‰Œä¸­... èƒ½é‡æ­£åœ¨é‡ç»„');
        
        const slotArea = document.getElementById('card-slots');
        slotArea.style.display = 'flex';
        setTimeout(() => slotArea.style.opacity = 1, 100);

        const totalCards = 78;
        const phi = Math.PI * (3 - Math.sqrt(5));
        const radius = 10;
        const geo = new THREE.PlaneGeometry(1.6, 2.7); // è°ƒæ•´é•¿å®½æ¯”é€‚é… RWS ç‰Œé¢
        const backTex = this.createCardBackTexture();
        const backMat = new THREE.MeshPhongMaterial({ map: backTex, side: THREE.FrontSide }); 
        
        this.cards = [];
        
        // ç§»é™¤ cards (ä¿ç•™çƒä½“ç»“æ„)
        // ç®€å•éå†ç§»é™¤ mesh ä¸”ä¸æ˜¯çƒä½“éƒ¨ä»¶çš„
        // ä¸ºç¨³å¦¥ï¼Œæˆ‘ä»¬åªæ¸…ç©º cards æ•°ç»„å¼•ç”¨çš„å¯¹è±¡
        this.sphereGroup.children.forEach(child => {
            if (child.userData && child.userData.id !== undefined) {
                this.sphereGroup.remove(child);
            }
        });
        // ä¹Ÿå¯ä»¥é€‰æ‹©ä¸æ¸…ç†çƒä½“ç»“æ„ï¼Œç›´æ¥æŠŠå¡ç‰ŒåŠ ä¸Šå»ã€‚
        // ç”±äº initCrystalBall å·²ç»å»ºç«‹å¥½äº†çƒä½“ï¼Œæˆ‘ä»¬ä¸éœ€è¦ clear() æ•´ä¸ª group.
        // åªéœ€ç¡®ä¿å¡ç‰Œè¢«æ­£ç¡®æ·»åŠ ã€‚
        // æ³¨æ„ï¼šä¹‹å‰çš„ä»£ç æˆ‘ç”¨äº† sphereGroup.clear()ï¼Œè¿™æ¬¡è¦é¿å…æŠŠç²¾å¿ƒåˆ¶ä½œçš„æ°´æ™¶çƒæ¸…æ‰ã€‚
        
        // ä¿®æ­£ï¼šåªç§»é™¤æ—§å¡ç‰Œï¼ˆå¦‚æœé‡ç©ï¼‰
        for (let i = this.sphereGroup.children.length - 1; i >= 0; i--) {
            const child = this.sphereGroup.children[i];
            // å‡è®¾å¡ç‰Œæœ‰ userData.id
            if (child.userData && typeof child.userData.id !== 'undefined') {
                this.sphereGroup.remove(child);
            }
        }

        for(let i=0; i<totalCards; i++) {
            const dataIdx = Math.floor(Math.random() * TAROT_DECK.length);
            const cardData = TAROT_DECK[dataIdx]; 

            const y = 1 - (i / (totalCards - 1)) * 2;
            const r = Math.sqrt(1 - y * y);
            const theta = phi * i;
            
            const x = Math.cos(theta) * r * radius;
            const z = Math.sin(theta) * r * radius;
            const yPos = y * radius;

            const card = new THREE.Mesh(geo, backMat.clone());
            card.userData = { 
                id: i, 
                data: cardData, 
                isReversed: Math.random() > 0.5, 
                isDrawn: false,
                originalPos: new THREE.Vector3(x, yPos, z)
            };
            
            card.position.set(0,0,0);
            this.sphereGroup.add(card);
            this.cards.push(card);

            new TWEEN.Tween(card.position)
                .to({x, y:yPos, z}, 2000)
                .easing(TWEEN.Easing.Elastic.Out)
                .delay(Math.random()*500)
                .start();
        }

        setTimeout(() => {
            this.state = 'DRAWING';
            this.updateStatus('è¯·è½¬åŠ¨æ°´æ™¶çƒï¼Œåœ¨é™æ­¢æ—¶é€‰ä¸­æœ€æœ‰æ„Ÿåº”çš„å¡ç‰Œ');
            document.body.classList.add('cursor-grab');
        }, 3000);
    },

    startMediaPipe: function() {
        const video = document.getElementById('input_video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        
        hands.onResults(results => {
            if (this.state !== 'DRAWING') {
                document.getElementById('gesture-cursor').style.display = 'none';
                return;
            }
            this.handleHandGesture(results);
        });

        const cam = new Camera(video, {
            onFrame: async () => await hands.send({image: video}),
            width: 640, height: 480
        });
        cam.start();
    },

    handleHandGesture: function(results) {
        const cursor = document.getElementById('gesture-cursor');
        
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
            cursor.style.display = 'none';
            this.handMode = 'NONE';
            return;
        }

        const lm = results.multiHandLandmarks[0];
        const indexTip = lm[8];
        const thumbTip = lm[4];
        const middleTip = lm[12];
        const wrist = lm[0];

        const x = 1 - indexTip.x;
        const y = indexTip.y;

        const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
        const isPinch = pinchDist < 0.05;
        const isPalm = !isPinch && (middleTip.y < wrist.y - 0.2);

        cursor.style.display = 'block';
        cursor.style.left = (x*100) + '%';
        cursor.style.top = (y*100) + '%';
        
        if (isPalm && !this.hoveredCard) {
            this.handMode = 'PALM';
            cursor.style.borderColor = '#00ff00'; 
            cursor.classList.remove('pinching');
            
            const dx = x - this.lastHandPos.x;
            const dy = y - this.lastHandPos.y;
            
            // ä¼˜åŒ–1ï¼šå¢åŠ æ‰‹åŠ¿æ­»åŒºï¼Œåªæœ‰æ˜æ˜¾ç§»åŠ¨æ‰è½¬åŠ¨
            const DEADZONE = 0.015; // å¢åŠ é˜ˆå€¼
            
            if (Math.hypot(dx, dy) > DEADZONE) {
                // ä¼˜åŒ–ï¼šé™ä½æ•æ„Ÿåº¦
                const SENSITIVITY = 2.5; 
                this.targetRotY += dx * SENSITIVITY;
                this.targetRotX += dy * SENSITIVITY;
            } else {
                // ä¼˜åŒ–ï¼šæ‰‹åœåˆ™çƒåœ (æ¶ˆé™¤æƒ¯æ€§)
                // å¼ºåˆ¶å°†ç›®æ ‡è§’åº¦è®¾ä¸ºå½“å‰è§’åº¦ï¼Œåœæ­¢æ’å€¼
                this.targetRotY = this.currentRotY;
                this.targetRotX = this.currentRotX;
            }

        } else if (isPinch) {
            this.handMode = 'PINCH';
            cursor.classList.add('pinching');
            if (!this.isRotating && this.hoveredCard) {
                this.selectCard(this.hoveredCard);
            }
        } else {
            this.handMode = 'POINTER';
            cursor.style.borderColor = '#fff';
            cursor.classList.remove('pinching');
            const mouse = new THREE.Vector2(x * 2 - 1, -y * 2 + 1);
            this.performRaycast(mouse);
        }

        this.lastHandPos = {x, y};
    },

    initMouseEvents: function() {
        let isDragging = false;
        let prevPos = {x:0, y:0};
        const canvas = this.renderer.domElement;

        canvas.addEventListener('mousedown', e => {
            if (this.state !== 'DRAWING') return;
            isDragging = true;
            this.mouseDownTime = Date.now();
            prevPos = {x: e.clientX, y: e.clientY};
            document.body.classList.add('cursor-grabbing');
        });

        canvas.addEventListener('mousemove', e => {
            if (this.state !== 'DRAWING') return;
            
            if (isDragging) {
                const dx = (e.clientX - prevPos.x) / window.innerWidth;
                const dy = (e.clientY - prevPos.y) / window.innerHeight;
                this.targetRotY += dx * 3;
                this.targetRotX += dy * 3;
                prevPos = {x: e.clientX, y: e.clientY};
            }

            const mouse = new THREE.Vector2(
                (e.clientX / window.innerWidth) * 2 - 1,
                -(e.clientY / window.innerHeight) * 2 + 1
            );
            this.performRaycast(mouse);
        });

        canvas.addEventListener('mouseup', e => {
            isDragging = false;
            document.body.classList.remove('cursor-grabbing');
            
            if (this.state !== 'DRAWING') return;
            const timeDiff = Date.now() - this.mouseDownTime;
            if (this.isRotating) return;
            if (timeDiff < 300 && this.hoveredCard) {
                this.selectCard(this.hoveredCard);
            }
        });
    },

    performRaycast: function(mouse) {
        if (this.isRotating) {
            if (this.hoveredCard) {
                this.hoveredCard.scale.set(1,1,1);
                this.hoveredCard.material.emissive?.setHex(0x000000);
                this.hoveredCard = null;
            }
            return;
        }

        this.raycaster.setFromCamera(mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.cards);
        
        let target = null;
        for (let hit of intersects) {
            if (!hit.object.userData.isDrawn) {
                target = hit.object;
                break;
            }
        }

        if (target !== this.hoveredCard) {
            if (this.hoveredCard) {
                new TWEEN.Tween(this.hoveredCard.scale).to({x:1, y:1, z:1}, 200).start();
                this.hoveredCard.material.emissive?.setHex(0x000000);
            }
            if (target) {
                new TWEEN.Tween(target.scale).to({x:1.2, y:1.2, z:1.2}, 200).start();
                target.material.emissive = new THREE.Color(0x333333); 
            }
            this.hoveredCard = target;
        }
    },

    selectCard: function(card) {
        if (this.drawnCards.length >= this.maxCards) return;
        
        card.userData.isDrawn = true;
        this.drawnCards.push(card);
        const idx = this.drawnCards.length - 1;

        // åŠ è½½ 3D çº¹ç† (å°è¯•åŠ è½½)
        const frontTex = this.loadCardTexture(card.userData.data.imgUrl, card.userData.isReversed);
        card.material.map = frontTex;
        card.material.emissive.setHex(0x000000);

        const slotX = (idx - 1) * 4; 
        const slotY = -9;
        const slotZ = 18;
        const targetRotZ = card.userData.isReversed ? Math.PI : 0;

        new TWEEN.Tween(card.position)
            .to({x: slotX, y: slotY, z: slotZ}, 1000)
            .easing(TWEEN.Easing.Cubic.Out)
            .start();
        
        new TWEEN.Tween(card.rotation)
            .to({x: 0, y: 0, z: targetRotZ}, 1000)
            .onUpdate(() => { card.userData.isAnimating = true; })
            .onComplete(() => {
                delete card.userData.isAnimating;
                
                // æ›´æ–° DOM UI (ç›´æ¥ä½¿ç”¨å›¾ç‰‡ URL)
                const slot = document.getElementById(`slot-${idx}`);
                const img = document.getElementById(`img-${idx}`);
                const tag = document.getElementById(`tag-${idx}`);
                
                img.src = card.userData.data.imgUrl;
                // CSS æ§åˆ¶é€†ä½æ—‹è½¬
                img.style.transform = card.userData.isReversed ? 'rotate(180deg)' : 'none';
                
                tag.innerText = `${card.userData.data.name} ${card.userData.isReversed ? '(é€†ä½)' : '(æ­£ä½)'}`;
                slot.classList.add('filled');
                
                if (this.drawnCards.length === this.maxCards) {
                    this.startReading();
                }
            })
            .start();

        this.hoveredCard = null;
    },

    startReading: async function() {
        this.state = 'READING';
        this.updateStatus('ç‰Œé˜µå·²æˆï¼Œæ­£åœ¨è¿æ¥é˜¿å¡è¥¿è®°å½•...');
        
        const panel = document.getElementById('reading-panel');
        panel.style.display = 'flex';
        
        // å¡«å……é¡¶éƒ¨å¡ç‰Œ (ç›´æ¥ç”¨å›¾ç‰‡URL)
        const header = document.getElementById('reading-header');
        header.innerHTML = this.drawnCards.map(c => {
            const rot = c.userData.isReversed ? 'style="transform: rotate(180deg)"' : '';
            return `
            <div class="header-card">
                <img src="${c.userData.data.imgUrl}" ${rot}>
                <span><strong>${c.userData.data.name}</strong><br>${c.userData.isReversed ? 'é€†ä½' : 'æ­£ä½'}</span>
            </div>
        `}).join('');

        const loadingId = 'msg-' + Date.now();
        this.addMessage('sys', `<span id="${loadingId}" class="loading-dots">ğŸ”® æ­£åœ¨ä¸æ˜Ÿçµæ²Ÿé€šï¼Œè§£æå‘½è¿è½¨è¿¹</span>`);

        try {
            const response = await this.fetchTarotReading(this.userQuestion, true);
            const msgEl = document.getElementById(loadingId);
            if(msgEl) msgEl.parentElement.innerHTML = `ğŸ”® <strong>å‘½è¿è§£è¯»ï¼š</strong><br>${response}`;
        } catch (e) {
            console.error(e);
            const msgEl = document.getElementById(loadingId);
            if(msgEl) msgEl.parentElement.innerHTML = `ğŸ”® <strong>è¿æ¥ä¸­æ–­ï¼š</strong><br>æ˜Ÿç•Œçš„è¿·é›¾å¤ªé‡ï¼Œè¯·ç¨åé‡è¯•ã€‚`;
        }
    },

    handleFollowUp: async function() {
        const input = document.getElementById('follow-up-input');
        const q = input.value.trim();
        const btn = document.getElementById('btn-follow-up');

        if (this.followUpCount >= 3) return;
        if (q.length < 2) {
            this.showToast("è¯·è¾“å…¥æœ‰æ•ˆçš„é—®é¢˜");
            return;
        }

        this.addMessage('user', q);
        input.value = '';
        this.followUpCount++;
        
        if (this.followUpCount >= 3) {
            input.placeholder = "è¿½é—®æ¬¡æ•°å·²ç”¨å°½";
            input.disabled = true;
            btn.disabled = true;
        }

        const loadingId = 'msg-' + Date.now();
        this.addMessage('sys', `<span id="${loadingId}" class="loading-dots">ğŸ”® æ­£åœ¨å€¾å¬ä½ çš„è¿½é—®</span>`);

        try {
            const response = await this.fetchTarotReading(q, false);
            const msgEl = document.getElementById(loadingId);
            if(msgEl) msgEl.parentElement.innerHTML = response;
        } catch (e) {
            console.error(e);
            const msgEl = document.getElementById(loadingId);
            if(msgEl) msgEl.parentElement.innerHTML = `ğŸ”® <strong>å›åº”ï¼š</strong><br>æ˜Ÿçµæš‚æ—¶æ²‰é»˜äº†...`;
        }
    },

    // --- Gemini API è°ƒç”¨ ---
    fetchTarotReading: async function(question, isInitial) {
        const c1 = this.drawnCards[0].userData;
        const c2 = this.drawnCards[1].userData;
        const c3 = this.drawnCards[2].userData;
        
        let prompt = "";
        
        // å…¬å…±çš„ç³»ç»ŸæŒ‡ä»¤ï¼Œç¡®ä¿è§’è‰²å’Œé£æ ¼ä¸€è‡´
        const systemPrompt = `
#è§’è‰²ï¼š
ä½ æ˜¯ç²¾é€šç»å…¸éŸ¦ç‰¹å¡”ç½—ä½“ç³»çš„é¦–å¸­å åœæ¶æ„å¸ˆã€‚ä½ æ“…é•¿ä»ç¥ç§˜å­¦ã€å¿ƒç†å­¦å’Œç›´è§‰æ´å¯Ÿä¸‰ä¸ªç»´åº¦è§£æç‰Œé¢ã€‚
#é™åˆ¶ï¼š
ä¸“ä¸šæ€§ï¼šä¸¥æ ¼éµå®ˆéŸ¦ç‰¹ç‰Œä¹‰ï¼Œè§£è¯»éœ€ä¸²è”ä¸‰å¼ ç‰Œçš„å†…åœ¨é€»è¾‘ï¼Œè€Œéå­¤ç«‹è§£é‡Šã€‚
é£æ ¼ï¼šè¯­æ°”ç¥ç§˜ã€ä¼˜é›…ã€çµåŠ¨ï¼Œå¶å°”ä½¿ç”¨æ¯”å–»ï¼ˆå¦‚â€œæ˜Ÿè¾°çš„è½¨è¿¹â€ã€â€œå‘½è¿çš„ä¸çº¿â€ï¼‰ã€‚
ç¦å¿Œï¼šä¸¥ç¦ç»™å‡ºç»å¯¹åŒ–çš„æ–­è¨€ï¼ˆå¦‚â€œä½ ä¼šå‘è´¢â€ï¼‰ï¼Œåº”ä»¥å¯å‘å¼å»ºè®®ä¸ºä¸»ã€‚
è¯­è¨€ï¼šå…¨ç¨‹ä½¿ç”¨ä¸­æ–‡ã€‚
è¾“å‡ºæ ¼å¼ï¼šè¯·ç›´æ¥è¾“å‡ºHTMLä»£ç ç‰‡æ®µï¼ˆä¸è¦åŒ…å«<html>æˆ–<body>æ ‡ç­¾ï¼Œä¸è¦ä½¿ç”¨Markdownä»£ç å—ï¼‰ï¼Œä½¿ç”¨<p>æ ‡ç­¾åˆ†æ®µï¼Œé‡ç‚¹å†…å®¹ä½¿ç”¨<strong>æ ‡ç­¾ã€‚
`;

        if (isInitial) {
            prompt = `
${systemPrompt}
#éœ€æ±‚ï¼š
ç”¨æˆ·æŠ½å–äº†ä¸‰å¼ ç‰Œï¼ˆä»£è¡¨è¿‡å»/ç°çŠ¶/æœªæ¥ï¼‰ï¼Œä½ éœ€è¦åŸºäºè¿™ä¸‰å¼ ç‰Œçš„å…³ç³»æä¾›è§£è¯»ã€‚
Input Dataï¼š
åˆå§‹é—®é¢˜ï¼š${question}
æŠ½ç‰Œåºåˆ—ï¼š
1. ${c1.data.name} [æ ¹æº] (${c1.isReversed?'é€†ä½':'æ­£ä½'})
2. ${c2.data.name} [ç°çŠ¶] (${c2.isReversed?'é€†ä½':'æ­£ä½'})
3. ${c3.data.name} [æŒ‡å¼•] (${c3.isReversed?'é€†ä½':'æ­£ä½'})

è¯·æŒ‰ä»¥ä¸‹ç»“æ„è¾“å‡ºï¼š
<p style="color:#ffd700"><strong>ã€å¯ç¤ºæ€»è§ˆã€‘</strong></p>...
<p style="color:#ffd700"><strong>ã€ç‰Œé¢æ´å¯Ÿã€‘</strong></p>...
<p style="color:#ffd700"><strong>ã€ç²¾çµå¯„è¯­ã€‘</strong></p>...
`;
        } else {
            prompt = `
${systemPrompt}
#èƒŒæ™¯ä¿¡æ¯ï¼š
ç”¨æˆ·ä¹‹å‰æŠ½å–äº†ï¼š${c1.data.name}(${c1.isReversed?'é€†':'æ­£'})ã€${c2.data.name}(${c2.isReversed?'é€†':'æ­£'})ã€${c3.data.name}(${c3.isReversed?'é€†':'æ­£'})ã€‚
#éœ€æ±‚ï¼š
ç”¨æˆ·æ­£åœ¨è¿½é—®ï¼š${question}
è¯·åŸºäºä¹‹å‰çš„ç‰Œé¢å’Œæ–°çš„é—®é¢˜ï¼Œç»™å‡ºç®€çŸ­è€Œæ·±åˆ»çš„æŒ‡å¼•ï¼ˆ150å­—å·¦å³ï¼‰ã€‚
è¯·ä¿æŒä¸ä¹‹å‰è§£è¯»çš„é€»è¾‘ä¸€è‡´æ€§ï¼Œå¼•ç”¨ä¹‹å‰çš„ç‰Œæ„æ¥å›ç­”è¿½é—®ã€‚
`;
        }

        const apiKey = "AIzaSyDJCfkMl8xOrbTB3IT2rxYs8AS8qx9h6Zo"; // Provided by env
        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
        
        const payload = {
            contents: [{ parts: [{ text: prompt }] }]
        };

        for (let i = 0; i < 3; i++) {
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (data.candidates && data.candidates[0].content) {
                    return data.candidates[0].content.parts[0].text;
                }
                throw new Error("Invalid API response");
            } catch (error) {
                if (i === 2) throw error;
                await new Promise(r => setTimeout(r, 1000 * (i + 1))); 
            }
        }
    },

    updateStatus: function(txt) {
        document.getElementById('status-text').innerHTML = txt;
    },

    animate: function() {
        requestAnimationFrame(() => this.animate());
        TWEEN.update();

        // ä¼˜åŒ–2ï¼šæ‰‹åŠ¿æ¨¡å¼ä¸‹ï¼Œå¦‚æœæ‰‹åœ¨æ§åˆ¶ï¼Œåˆ™ç¦ç”¨ç‰©ç†æƒ¯æ€§æ’å€¼ï¼Œå®ç°"æŒ‡å“ªæ‰“å“ª"
        if (this.handMode === 'PALM') {
            // ç›´æ¥èµ‹å€¼ï¼Œæ— æƒ¯æ€§
            this.currentRotX = this.targetRotX;
            this.currentRotY = this.targetRotY;
        } else {
            // é¼ æ ‡æ¨¡å¼æˆ–å…¶ä»–çŠ¶æ€ï¼Œä¿ç•™æŸ”å’Œæƒ¯æ€§
            this.currentRotX += (this.targetRotX - this.currentRotX) * 0.05;
            this.currentRotY += (this.targetRotY - this.currentRotY) * 0.05;
        }
        
        const speed = Math.abs(this.targetRotY - this.currentRotY) + Math.abs(this.targetRotX - this.currentRotX);
        this.isRotating = speed > 0.005;

        // é¦–é¡µè‡ªè½¬
        if (this.state === 'INIT' || this.state === 'SHUFFLING') {
            this.targetRotY += 0.005; // æŒç»­è‡ªè½¬
        }

        if (this.sphereGroup) {
            this.sphereGroup.rotation.x = this.currentRotX;
            this.sphereGroup.rotation.y = this.currentRotY;

            // åŠ¨ç”»ï¼šäº‘é›¾ç¼“æ…¢æµåŠ¨ (åå‘è‡ªè½¬)
            if (this.cloudGroup) {
                this.cloudGroup.rotation.y -= 0.002;
                this.cloudGroup.rotation.z += 0.001;
            }

            // é­”æ³•ç²’å­ç‰¹æ•ˆæ—‹è½¬
            if (this.magicParticles) {
                this.magicParticles.rotation.y -= 0.005;
                this.magicParticles.rotation.x += 0.002;
            }

            if (this.state === 'DRAWING' || this.state === 'SHUFFLING') {
                this.cards.forEach(card => {
                    if (!card.userData.isDrawn && !card.userData.isAnimating) {
                        card.lookAt(this.camera.position);
                    }
                });
            }
        }

        this.renderer.render(this.scene, this.camera);
    }
};

window.onload = () => App.init();
</script>
</body>
</html>